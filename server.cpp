#include <assert.h>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <iterator>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h> 
#include <sys/poll.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include<arpa/inet.h>
#include <stdbool.h>
#include <string.h>
#include <vector>
#include <poll.h>
#include <fcntl.h>
//state must be stored in here
struct Conn{
    int fd = -1; 
    //intention for event loop
    bool want_read = false; 
    bool want_write = false;
    bool want_close = false; // to destroy collection 
    std::vector<uint8_t> incoming; //data to be parsed 
    std::vector<uint8_t> outgoing; //responses generated by application

};
const size_t k_max_msg = 4096;

static void buf_append(std::vector<uint8_t> & buf, const uint8_t * data, size_t len){
    //insert data +len data times 
    buf.insert(buf.end(), data, data +len);
}

static void buf_consume(std::vector<uint8_t> & buf, size_t n){

    buf.erase(buf.begin(), buf.begin() + n);
}
// to make the listening socket
static void fd_set_nb(int fd){
    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
}

static bool try_one_request(Conn * conn){
    //try to parse accumulated buffer
    if(conn -> incoming.size() < 4){
        return false;
    }

    uint32_t len = 0; 
    memcpy(&len, conn -> incoming.data(), 4);
    if(len > k_max_msg){
        conn -> want_close = true; 
        return false; 
    }

    if(4 + len > conn -> incoming.size()){
        return false; 
    }
    
    const uint8_t * request = &conn -> incoming[4];
    buf_append(conn -> outgoing, (const uint8_t *)&len, 4);
    buf_append(conn -> outgoing, request, len); 
    buf_consume(conn -> incoming, 4 + len); 
    return true;


}


static Conn * handle_accept(int fd){
    struct sockaddr_in client_addr = {};
    socklen_t socklen = sizeof(client_addr);
    int connfd = accept(fd, (struct sockaddr *) &client_addr, &socklen);
    
    if(connfd < 0){
        return NULL;
    }
    //set new connection fd to nonblocking mode 
    fd_set_nb(connfd);
    Conn * conn = new Conn();
    conn -> fd = connfd; 
    conn -> want_read = true; 
    return conn;


}
static void handle_write(Conn * conn){
    assert(conn -> outgoing.size() > 0); 
    ssize_t rv = write(conn -> fd, conn -> outgoing.data(), conn -> outgoing.size());
    
    if(rv < 0){
        conn -> want_close = true;
        return;
    }
    
    buf_consume(conn -> outgoing, (size_t)rv); 
    if(conn -> outgoing.size() == 0){
        conn -> want_read = true; 
        conn -> want_write = false;
    }

}

static void handle_read(Conn * conn){
    // do a non blocking read
    uint8_t buf[64 * 1024];

    ssize_t rv = read(conn -> fd, buf, sizeof(buf));

    if(rv <= 0){
        //handle io error if rv < 0 or eof rv == 0
        conn -> want_close = true; 
        return;
    }
    
    buf_append(conn -> incoming, buf, (size_t)rv); 
    try_one_request(conn);
    
    if(conn -> outgoing.size() > 0){
        conn -> want_read = false; 
        conn -> want_write = true;
    }

}


static int32_t read_full(int fd, char * buf, size_t n){ //function cannot be called from outside file
    while(n > 0){
        // n is count of items
        ssize_t rv = read(fd, buf, n); 
        if(rv <= 0){
            return -1; //unexpected end of file
        }

        assert((size_t)rv <= n);
        n -= (size_t) rv;
        buf += rv;

    }

    return 0;


}

static int32_t write_all(int fd, const char * buf, size_t n){
    while(n > 0){
        ssize_t rv = write(fd, buf, n);

        if(rv <= 0){
            return -1;
        }
        assert((size_t)rv <= n);
        n -= (size_t)rv; 
        buf += rv;

    }
    return 0;
}

static void die(const char * msg){
    int err = errno;
    fprintf(stderr,"[%d] %s\n", err, msg);
    abort();

}

static void msg(const char * msg){
    //print error message
    fprintf(stderr, "%s\n", msg);
}



static int32_t one_request(int connfd){
    
    char rbuf[4+k_max_msg]; 
    errno = 0; 
    int32_t err = read_full(connfd, rbuf, 4); 
    
    if(err){
        msg(errno == 0 ?"EOF": "read()error");
        return err;
    }
    
    uint32_t len = 0;
    //compute to see if length of recerived message is too long
    memcpy(&len, rbuf, 4);
    if(len > k_max_msg){
        msg("too long"); 
        return -1;
    }
    //request body
    err = read_full(connfd, &rbuf[4], len);
    if(err){
        msg("read() error");
        return err;
    }

    printf("client says: %.*s\n", len, &rbuf[4]);
    const char reply[] = "world"; 
    char wbuf[4 + sizeof(reply)];
    len = (uint32_t) strlen(reply); 
    memcpy(wbuf, &len, 4); 
    memcpy(&wbuf[4], reply, len);
    return write_all(connfd, wbuf, 4+len);
}

int main(){
    int fd = socket(AF_INET, SOCK_STREAM, 0); 

    if(fd <  0){
        //if socket handle is retrieved incorrectly
        die("socket()");
    }
    

    struct sockaddr_in addr = {}; // in arpa inet .h 
                                  // holds ipv4 port pair stored as big endian numbers
                                
    addr.sin_family = AF_INET;
    addr.sin_port = ntohs(1234); //port 1234 in big endian
    addr.sin_addr.s_addr = htonl(0); //wildcard ip address
                                     //htonl swaps endianness from cpu endian to big endian
    int rv = bind(fd, (const struct sockaddr*)&addr, sizeof(addr));
    

    if(rv){
        //if rv does not bind to a port correctly
        die("bind()");
    }
    
    
    //listen
    rv = listen(fd, SOMAXCONN); //listen on port which fd has been bound to with size of queue SOMAXCONN which is 4096
    if (rv) {
        die("listen()"); 
    }
    
    std::vector<Conn *> fd2conn;
    std::vector<struct pollfd> poll_args;
    while(true){ 
        poll_args.clear();        
        
        //put listening sockets in the first position
        struct pollfd pfd = {fd, POLL_IN, 0};
        poll_args.push_back(pfd);

        for(Conn * conn: fd2conn){
            if(!conn){
                //continue
                continue;
            }
            
            struct pollfd pfd = {conn -> fd, POLLERR, 0};
            
            if(conn -> want_read){
                pfd.events |= POLLIN; //pfd.events = pfd.events | POLLIN 
            }

            if(conn -> want_write){
                pfd.events |= POLLOUT; 
            }

            poll_args.push_back(pfd);
        }


        //prep args dfor poll and waitr for readiness
        int rv = poll(poll_args.data(), (nfds_t)poll_args.size(), -1);
        
        if(rv < 0){
            die("poll");
        }
        
        if(poll_args[0].revents){
            if(Conn * conn = handle_accept(fd)){
                //put into the map

                if(fd2conn.size() <= (size_t)conn ->fd){
                    fd2conn.resize(conn -> fd + 1);
                }

                fd2conn[conn -> fd] = conn;
            }

            for(size_t i = 1; i < poll_args.size(); ++i){
                uint32_t ready = poll_args[i].revents;
                Conn * conn = fd2conn[poll_args[i].fd];
                if(ready & POLLIN){
                    handle_read(conn); // using bitwise and operation if both bits are the same and 1 
                                       // if not then the specific bit is zero
                }

                if(ready & POLLOUT){
                    handle_write(conn); 

                } 
                    
                if((ready & POLLERR) || conn -> want_close){
                    (void) close (conn -> fd); 
                    fd2conn[conn -> fd] = NULL; 
                    delete conn;

                }


            }

            


        }




    }

    return 0;

}
